---
layout: post
title: "[알고리즘] 프로그래머스 표 편집 swift 풀이"
date: 2022-04-28 14:34:10 +0700
excerpt: 2021 카카오 인턴십 정확성/효율성 기출
categories: [Algorithm]
tags: [Algorithm, Kakao]
---

## **1️⃣ 문제**

> 문제 - 모음사전
>
> [풀이 참조 - Kakao Tech 블로그](https://tech.kakao.com/2021/07/08/2021-카카오-인턴십-for-tech-developers-코딩-테스트-해설/)

테크 블로그에서 풀이를 참조하니, 양방향 링크드 리스트로 풀이하는거였다!

## 2️⃣ 풀이 방법 및 코드

### 1️⃣ 처음 풀이 방법(🙅‍♀️swift로 풀면 안되는 코드)

처음에는 [이 유투브 영상](https://www.youtube.com/watch?v=4ROnLIUFKbw)을 참조하여 풀었지만, swift로 이와 같은 로직으로 해결하고자 하면 풀어지지 않음! 그 이유는 이따 밝히는 걸로 하고..!

<img src="https://user-images.githubusercontent.com/47033052/165779418-76a3d30d-1f84-43c2-b10c-18edac6275e9.png" width="40%" />

**Node**의 프로퍼티는 아래와 같이 정의하고,

- `isRemoved`: 삭제 여부를 나타내는 Bool
- `prev`: 이전 노드
- `next`: 다음 노드

**nodeArr**

```swift
import Foundation

class Node {
    var isRemoved: Bool
    var prev: Node?
    var next: Node?

    init() {
        self.isRemoved = false
        self.prev = nil
        self.next = nil
    }
}

func solution(_ n:Int, _ k:Int, _ cmd:[String]) -> String {
    let nodeArr = Array(repeating: Node(), count: n)    // 삭제 여부를 담는 노드 배열
    var selected: Node = nodeArr[k]     // 현재 선택 행
    var deletedStack = [Node]() // 삭제된 행을 담는 스택 휴지통
    var answer = ""

    // 링크드 리스트 연결하기
    for i in 1..<n {
        nodeArr[i].prev = nodeArr[i-1]
        nodeArr[i-1].next = nodeArr[i]
    }

    // 명령어 실행
    cmd.forEach {
        let c = $0.first!
        switch c {
            case "U":
            let move = $0.last!.wholeNumberValue!
            for _ in 0..<move { selected = selected.prev! }
            case "D":
            let move = $0.last!.wholeNumberValue!
            for _ in 0..<move { selected = selected.next! }
            case "C":
            deletedStack.append(selected)
            selected.isRemoved.toggle()
            let up = selected.prev
            let down = selected.next
            if up != nil { up!.next = down }
            if down != nil {
                down!.prev = up
                selected = down!
            } else {
                selected = up!
                return
            }
            default:
            let node = deletedStack.removeLast()
            node.isRemoved.toggle()
            let up = node.prev
            let down = node.next
            if up != nil { up!.next  = node }
            if down != nil { down!.prev  = node }
        }
    }

    nodeArr.forEach { answer += !$0.isRemoved ? "O": "X" }
    return answer
}
```

### 2️⃣ 왜 Swift로 풀면 안되는 거야?

``` swift
for i in 0..<nodeArr.count {
        withUnsafePointer(to: &nodeArr[i]) { print($0) }
}
```

### 3️⃣ 코드

``` swift
import Foundation

class Node {
    var idx = 0
    var prev: Node?
    var next: Node?
}

func solution(_ n:Int, _ k:Int, _ cmd:[String]) -> String {
    var node = Node()
    var selected = node     // 현재 선택 행
    var deletedStack = [Node]() // 삭제된 행을 담는 스택 휴지통
    var answer = [String](repeating: "O", count: n)
    
    // 링크드 리스트 연결하기
    for i in 1..<n {
        node.next = Node()
        node.next?.prev = node
        node.next?.idx = i
        if i == k { selected = node.next! }
        node = node.next!
    }
    
    // 명령어 실행
    cmd.forEach {
        let c = $0.first!
        switch c {
        case "U":       // "U X"
            let move = Int($0.split(separator: " ").map { String($0) }[1])!
            for _ in 0..<move { selected = selected.prev! }
        case "D":       // // "D X"
            let move = Int($0.split(separator: " ").map { String($0) }[1])!
            for _ in 0..<move { selected = selected.next! }
        case "C":       // "C"
            deletedStack.append(selected)
            answer[selected.idx] = "X"
            let up = selected.prev
            let down = selected.next
            up?.next = down
            guard down != nil else {
                selected = up!
                return
            }
            down!.prev = up
            selected = down!
            
        default:        // "Z"
            let restore = deletedStack.removeLast()
            answer[restore.idx] = "O"
            let up = restore.prev
            let down = restore.next
            up?.next = restore
            down?.prev = restore
        }
    }
    
    return answer.joined()
}
```

## 3️⃣ 이 문제를 풀면서 되새긴 점