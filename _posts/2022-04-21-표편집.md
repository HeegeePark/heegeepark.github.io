---
layout: post
title: "[알고리즘] 프로그래머스 표 편집 swift 풀이"
date: 2022-04-21 14:34:10 +0700
excerpt: 2021 카카오 인턴십 정확성/효율성 기출
categories: [Algorithm]
tags: [Algorithm, Kakao]
---

## 1️⃣ 문제

> [문제 - 모음사전](https://programmers.co.kr/learn/courses/30/lessons/84512)
>
> [풀이 참조 - Kakao Tech 블로그](https://tech.kakao.com/2021/07/08/2021-%ec%b9%b4%ec%b9%b4%ec%98%a4-%ec%9d%b8%ed%84%b4%ec%8b%ad-for-tech-developers-%ec%bd%94%eb%94%a9-%ed%85%8c%ec%8a%a4%ed%8a%b8-%ed%95%b4%ec%84%a4/)

구현은 어렵지 않은데 규칙을 생각하려니 머리 쪼개지는 문제였다 ..

그래서 dp는 점화식 찾는게 쉽지 않네 흑흑



## 2️⃣ 풀이 방법 및 코드

말 그대로 규칙을 찾는 것이 관건인 문제!

다른 풀이를 참조해도 이해하느라 애먹었다.. 직접 조합 하나 하나 써가면서 끄적여야 이해가 되더라 ^^!

### 1️⃣ 그래서 규칙이 무엇?

아래처럼 각 자리수마다 다음 알파벳이 바뀔 때마다 저만큼 수가 차이가 나는데 이게 어떻게 나왔냐면

```swift
import Foundation

class Node {
    var isRemoved: Bool
    var prev: Node?
    var next: Node?
    
    init() {
        self.isRemoved = false
        self.prev = nil
        self.next = nil
    }
}

func solution(_ n:Int, _ k:Int, _ cmd:[String]) -> String {
    let nodeArr = Array(repeating: Node(), count: n)    // 삭제 여부를 담는 노드 배열
    var selected: Node = nodeArr[k]     // 현재 선택 행
    var deletedStack = [Node]() // 삭제된 행을 담는 스택 휴지통
    var answer = ""
    
    // 링크드 리스트 연결하기
    for i in 1..<n {
        nodeArr[i].prev = nodeArr[i-1]
        nodeArr[i-1].next = nodeArr[i]
    }
    
    // 명령어 실행
    cmd.forEach {
        let c = $0.first!
        switch c {
            case "U":
            let move = $0.last!.wholeNumberValue!
            for _ in 0..<move { selected = selected.prev! }
            case "D":
            let move = $0.last!.wholeNumberValue!
            for _ in 0..<move { selected = selected.next! }
            case "C":
            deletedStack.append(selected)
            selected.isRemoved.toggle()
            let up = selected.prev
            let down = selected.next
            if up != nil { up!.next = down }
            if down != nil {
                down!.prev = up
                selected = down!
            } else {
                selected = up!
                return
            }
            default:
            let node = deletedStack.removeLast()
            node.isRemoved.toggle()
            let up = node.prev
            let down = node.next
            if up != nil { up!.next  = node }
            if down != nil { down!.prev  = node }
        }
    }
    
    nodeArr.forEach { answer += !$0.isRemoved ? "O": "X" }
    return answer
}
```

자리 수가 높아질 때 마다 **(x5) + 1**만큼 커지는 규칙이다!

(입출력 예에서 A는 1이고, I는 1563인 것에서 두 알파벳 간의 차이는 1562이니까 E는 절반인 781인 것으로 접근해서 규칙 찾을 수도 있음!)

### 2️⃣ 규칙의 원리

그렇다면 왜 5를 곱하고 1을 더할까?

5는 모음의 갯수이고, 마지막 1을 더하는 이유는 해당 자리에 공백이 오는 경우(그 경우가 딱 한번이라서 그래서 곱한 후 한번만 더 하는거)를 더하기 때문이다!

### 3️⃣ 코드

주소값 다른거 확인

``` swift
for i in 0..<nodeArr.count {
        withUnsafePointer(to: &nodeArr[i]) { print($0) }
}
```

![image-20220424231313094](/Users/heegeepark/Library/Application Support/typora-user-images/image-20220424231313094.png)

## 3️⃣ 이 문제를 풀면서 되새긴 점

DP 문제 많이 풀어서 감 익히자 ㅎㅎㅎㅎㅎㅎ
